# Concrete Issues (and some proposed solutions)

The following is a list of some of the linguistic issues that I have identified in the Specification, divided according to "T-shirt size".

## LARGE:

- The Specification lacks a Single Source of Truth  
  The formal Specification is comprised of the Specification [documents](https://modelcontextprotocol.io/specification/2025-06-18), and the TypeScript/JSON Schema. The latter defines the interfaces and data structures formally recognized by the Protocol messaging system, while the latter describes the Protocol more broadly. The problem is that the Schema is full of comments (JSDoc-style comments, inline comments, etc.), which are written in formal English language (they use the formal language of MUST/SHOULD/MAY), which overlap with the content of the Spec docs. Since both sources are classified as authoritative, the Protocol is indeterminate if they ever happen to contradict each other.
- The purpose of the Schema is unclear  
  If the Schema were _merely_ a formal, strictly typed enumeration of all classes and data structures recognized by the Specification, it might serve as a particularly rigorous and computationally accessible sub-component of the Specification as a whole. But the decision to use English, formal English, _and_ TypeScript as the languages for expressing the Specification is not made clear. Why does the Schema contain any English? (I assume the comments and JSDoc strings are also authoritative.) Are the comments supplementary or do they contain information not contained in the Schema? If it's the latter, why are they not written in the English documentation part? Requirements are often repeated, with slightly different wording in both the Schema and the Spec docs - this is confusing for readers; difficult for authors, who must ensure consistency across two document sources; and opens the door for inconsistency, which is "fatal" for a formal technical Spec.

## MEDIUM:

- The Specification is not entirely compliant with JSON-RPC 2.0 - which, in itself, is of no importance, except that the Spec states that JSON-RPC is part of the base protocol.
  One minor deviation is explicitly noted (regarding the use of `null` as an `id`). I have identified two other places where I believe the Specification strays from JSON-RPC - in one case, deliberately (I think), but without proper documentation to the reader (no support for batching); in the other case, probably an oversight (`SubscribeRequest` and `UnsubscribeRequest` are Requests which lack a corresponding `(Un)SubscribeResult`).
- Some requirements of the Specification are tacit, implied, or must be inferred, perhaps via a holistic reading of the documents as a whole.
  For instance: The "Capabilities" object is structured as follows - for each potential non-experimental capability, if the client/server supports it, they indicate this by including that property in the Capabilities object, possibly as a key with an empty dictionary as a value. Sub-capabilities are then declared as `sub_capability: true` inside that specific capability's value. Each of these correspond to messages, or methods, that the server or client support. But the object is not an exhaustive enumeration. For instance, the `tools/list` method is not declared - presumably it is to be inferred by the presence of the `tools` property - but is this actually made clear anywhere? (Is it even the case? From my reading, this cannot be inferred without interpretation.) Why not simply eliminate the need for interpretation - for the reader to browse through the whole Specification, in order to reason about the Capabilities object, when a complete enumeration would be a simple remedy?
- The Specification documents frequently use language that leaves room for interpretation, when explicit, legalistic language would be more appropriate. For instance, the Spec talks often about what capabilities clients and servers "support" - but the notion of "support" is never formally defined or clarfied. For instance - what does it mean to say that a server "supports Resources"? From a technical point of view, is it equivalent to saying that the server will respond to `resources/list` Requests by listing their Resources (all, some, a few)? If so, why not simply state this explicitly? Another issue is the use of descriptive language where prescriptive or imperative language is appropriate. For instance (example chosen at random): "To discover available resources, clients send a `resources/list` request." How is this to be read? Clients MAY send such a request? Clients MUST send such a request if they wish to discover available resources? Compare these expressions and decide which is clearer from a formal point of view:

1. To discover available resources, clients send a `resources/list` request. This operation supports pagination.
2. To discover available resources, clients may send a `resources/list` request. Clients SHOULD only send this request if the server has announced this capability. Servers who support resources MUST respond to these requests with a full list of resources available to that client. This response MUST support pagination.

- The use of the term "result" is confusing. A Result is sometimes used in place of "a successful response" but `result` is also a _property_ of a successful response. Note the two ways it is used in this statement, which speaks about "successful results" (which probably means "successful responses"), and then also as a property that must be set:
  > Responses are further sub-categorized as either successful results or errors. Either a result or an error MUST be set. A response MUST NOT set both.

## Small

- The Spec mentions the term "sub-resource" but the term is never defined.
-

# Recommendations

- Strictly define and enforce Separation of Concerns - if part of the Specification must be expressed in TypeScript, it must be clear _why_. Comments should be entirely removed from the Schema. If TypeScript is not a sufficiently rich language to express the Schema, it should not be used as an authoritative source. Move all the definitions into the Spec documents, where English commentary is appropriate - use programming language conventions to express certain aspects when needed, but don't require readers to cross-reference two sets of documents, one in English, and one in a programming language with extensive comments. Why make the reader conversant in the syntax of TypeScript interfaces, when the same things can be expressed in English, especially if the TypeScript Schema is not sufficiently clear without additional comments?

- Remove potentially ambiguous language from the Specification, and use formal language in its place. Leverage formal, functional definitions instead when possible. (Example: JSON-RPC declares that the lack of an `id` is _constitutive_ of a Notification - it states a clear formal criterion, before offering some comments about what the larger purpose is of Notifications.) Eliminate the use of terms like "supports" unless they are formally defined. Replace descriptive language (which is appropriate for a user guide) with prescriptive language. Do not rely on any tacit knowledge or "commonsense assumptions", especially when dealing with data structures like the Capabilities object. Ideally, do not require the reader to make subtle inferences based on statements and definitions that are distributed across many documents/pages. Proactively look for opportunities for (mis-)interpretation and just eliminate them with explicit language. Prefer redundancy in some case, for simple prescriptions, or simply refer the reader back to the general requirements, if they are stated formally.

- Make a clearer delineation between the Specification and the User Guide - establish the Specification as a formal, technical document, and use appropriate language, even if it involves dry or "legalistic" verbiage. Then the Spec is the Spec and the guides are more user-friendly presentations of the formal content of the Spec. If the Spec is complex and nuanced, do not rely heavily on broad "principles" such as those stated in the Overview - these could probably be interpreted in a way that resolves all ambiguity that I have identified in this document - but the reader should not have to engage in complex hermeneutics in order to understand the Spec.

- Establish up front what constraints JSON-RPC imposes on the Specification. (Requests MUST include an `id`, etc. - quite brief, really). This would eliminate the need to re-state these things in the Specification when describing various message types and expected behavior. If the Spec says that it uses JSON-RPC 2.0 as the base messaging protocol, then just state up front (as a convenience) what this means for every Request, Response, Notification, etc. - or simply refer the reader to the relevant definition and omit it from the Specification. (This is the case with respect to MUST/SHOULD/MAY, which are technical terms with nuanced definitions that are used but not _redeclared_ in the Spec.) There is no need to re-declare constraints that are already established in the JSON-RPC spec (although doing so once may help some readers), and doing so may lead to mis-interpretation or mis-alignment.
